<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preload" href="./assets/brainstem.glb" as="fetch" crossorigin />
    <title>Subject Project Hub</title>
    <style>
      :root {
        --bg-0: #070d1a;
        --bg-1: #0e1830;
        --bg-2: #121f3b;
        --text: #e9efff;
        --muted: #9ab0dd;
        --accent: #6fc2ff;
        --accent-2: #e0bd72;
        --accent-3: #8ef0c8;
        --edge: rgba(84, 112, 173, 0.46);
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        margin: 0;
        min-height: 100%;
      }

      body {
        color: var(--text);
        font-family: "Segoe UI", -apple-system, BlinkMacSystemFont, sans-serif;
        background:
          radial-gradient(900px 700px at 82% -16%, rgba(111, 194, 255, 0.2), transparent 62%),
          radial-gradient(700px 560px at 8% 108%, rgba(224, 189, 114, 0.17), transparent 58%),
          linear-gradient(155deg, var(--bg-0), var(--bg-1));
        overflow: hidden;
        caret-color: transparent;
      }

      #depth-layer,
      #lattice-layer {
        position: fixed;
        inset: 0;
        width: 100%;
        height: 100%;
      }

      #depth-layer {
        z-index: 0;
        opacity: 0.78;
      }

      #lattice-layer {
        z-index: 2;
        pointer-events: none;
      }

      .scan-noise {
        position: fixed;
        inset: 0;
        pointer-events: none;
        z-index: 1;
        background-image:
          repeating-linear-gradient(
            0deg,
            rgba(255, 255, 255, 0.014) 0px,
            rgba(255, 255, 255, 0.014) 1px,
            transparent 2px,
            transparent 4px
          ),
          radial-gradient(circle at 22% 16%, rgba(255, 255, 255, 0.07), transparent 34%),
          radial-gradient(circle at 72% 74%, rgba(255, 255, 255, 0.06), transparent 38%);
        mix-blend-mode: screen;
      }

      .cosmos-shell {
        position: relative;
        z-index: 3;
        width: min(1240px, 100%);
        min-height: 100vh;
        margin: 0 auto;
        padding: 18px;
        display: grid;
      }

      .starfield {
        position: relative;
        border: 1px solid rgba(48, 69, 112, 0.72);
        border-radius: 24px;
        overflow: hidden;
        user-select: none;
        background: linear-gradient(160deg, rgba(10, 18, 34, 0.8), rgba(8, 14, 30, 0.9));
        box-shadow:
          inset 0 1px 0 rgba(255, 255, 255, 0.06),
          0 32px 62px rgba(0, 0, 0, 0.56);
      }

      .starfield::before {
        content: "";
        position: absolute;
        inset: 0;
        pointer-events: none;
        background:
          radial-gradient(
            circle at var(--brain-glow-x, 50%) var(--brain-glow-y, 50%),
            rgba(111, 194, 255, 0.2),
            transparent 43%
          ),
          radial-gradient(
            circle at var(--brain-glow-x, 50%) var(--brain-glow-y, 50%),
            rgba(224, 189, 114, 0.08),
            transparent 28%
          );
        transition: background-position 120ms linear;
      }

      .starfield::after {
        content: "";
        position: absolute;
        inset: 0;
        pointer-events: none;
        opacity: var(--subject-alert-opacity, 0);
        background:
          radial-gradient(
            circle at var(--brain-glow-x, 50%) var(--brain-glow-y, 50%),
            rgba(255, 72, 72, 0.34),
            transparent 36%
          ),
          radial-gradient(
            circle at var(--brain-glow-x, 50%) var(--brain-glow-y, 50%),
            rgba(255, 22, 22, 0.16),
            transparent 24%
          );
        transition: opacity 420ms ease;
      }

      .starfield.subject-alert-critical::after {
        animation: subjectCriticalBlink 0.72s ease-in-out infinite;
      }

      @keyframes subjectCriticalBlink {
        0%,
        100% {
          filter: brightness(0.9) saturate(1);
        }
        50% {
          filter: brightness(1.26) saturate(1.25);
        }
      }

      .map-hud {
        position: absolute;
        top: 14px;
        left: 14px;
        right: 14px;
        z-index: 4;
        display: flex;
        justify-content: space-between;
        gap: 12px;
        pointer-events: none;
        opacity: 0;
        transition: opacity 360ms ease;
      }

      .chip {
        pointer-events: auto;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        border: 1px solid rgba(111, 194, 255, 0.4);
        border-radius: 999px;
        background: rgba(14, 24, 45, 0.72);
        color: var(--muted);
        padding: 8px 12px;
        font-size: 0.75rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }

      button.chip {
        font: inherit;
        cursor: pointer;
      }

      .chip-reset-btn {
        width: 38px;
        height: 38px;
        padding: 0;
        justify-content: center;
      }

      .chip-reset-btn svg {
        width: 18px;
        height: 18px;
      }

      .chip-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: var(--accent-3);
        box-shadow: 0 0 12px rgba(142, 240, 200, 0.72);
      }

      .organism {
        position: relative;
        width: 100%;
        height: min(84vh, 860px);
        perspective: 1600px;
        --brain-tilt-x: 0deg;
        --brain-tilt-y: 0deg;
        opacity: 0;
        filter: blur(4px);
        transition: opacity 460ms ease, filter 460ms ease;
      }

      .starfield.ready .map-hud {
        opacity: 1;
      }

      .starfield.ready .organism {
        opacity: 1;
        filter: blur(0);
      }

      .terminal-dock {
        position: absolute;
        left: 14px;
        right: 14px;
        top: 14px;
        bottom: 14px;
        z-index: 7;
        display: flex;
        align-items: flex-end;
        pointer-events: none;
        opacity: 1;
        transform: translateY(0);
        transition: opacity 340ms ease, transform 420ms ease;
      }

      .terminal-dock.expanded .terminal {
        height: 100%;
        border-color: rgba(111, 194, 255, 0.62);
        box-shadow: 0 28px 56px rgba(0, 0, 0, 0.62), 0 0 42px rgba(111, 194, 255, 0.28);
      }

      .terminal {
        width: 100%;
        height: clamp(176px, 24vh, 228px);
        display: flex;
        flex-direction: column;
        border: 1px solid rgba(111, 194, 255, 0.48);
        border-radius: 14px;
        background: linear-gradient(180deg, rgba(12, 22, 42, 0.86), rgba(8, 14, 28, 0.82));
        box-shadow: 0 22px 44px rgba(0, 0, 0, 0.56), 0 0 32px rgba(111, 194, 255, 0.2);
        overflow: hidden;
        backdrop-filter: blur(3px);
        transition: height 460ms ease, border-color 220ms ease, box-shadow 220ms ease;
        pointer-events: auto;
        transform-origin: bottom center;
      }

      .terminal-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        padding: 10px 14px;
        border-bottom: 1px solid rgba(111, 194, 255, 0.24);
        background: rgba(18, 33, 62, 0.65);
        text-transform: uppercase;
        letter-spacing: 0.08em;
        font-size: 0.72rem;
        color: var(--muted);
      }

      .terminal-head-actions {
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }

      .terminal-protocol-btn {
        border: 1px solid rgba(111, 194, 255, 0.44);
        border-radius: 999px;
        background: rgba(9, 17, 33, 0.78);
        color: #d4e4ff;
        font-family: inherit;
        font-size: 0.72rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        padding: 4px 10px;
        cursor: pointer;
      }

      .terminal-protocol-btn:hover,
      .terminal-protocol-btn:focus-visible {
        border-color: rgba(142, 240, 200, 0.72);
        color: #8ef0c8;
        outline: none;
      }

      .starfield.map-active .terminal-protocol-btn {
        animation: protocolEdgePulse 2.8s ease-in-out infinite;
      }

      @keyframes protocolEdgePulse {
        0%,
        100% {
          box-shadow:
            inset 0 0 0 0 rgba(142, 240, 200, 0),
            inset 0 0 0 rgba(142, 240, 200, 0),
            0 0 0 rgba(142, 240, 200, 0);
        }
        50% {
          box-shadow:
            inset 0 0 0 1.5px rgba(142, 240, 200, 0.42),
            inset 0 0 14px rgba(142, 240, 200, 0.2),
            0 0 8px rgba(111, 194, 255, 0.16);
        }
      }

      .terminal-close {
        border: 1px solid rgba(111, 194, 255, 0.44);
        border-radius: 999px;
        background: rgba(9, 17, 33, 0.78);
        color: #d4e4ff;
        font-family: inherit;
        font-size: 0.95rem;
        letter-spacing: 0;
        text-transform: none;
        line-height: 1;
        width: 30px;
        height: 24px;
        padding: 0;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
      }

      .terminal-close:hover,
      .terminal-close:focus-visible {
        border-color: rgba(142, 240, 200, 0.72);
        color: #8ef0c8;
        outline: none;
      }

      .terminal-body {
        padding: 12px 14px 8px;
        flex: 1 1 auto;
        min-height: 0;
        overflow: auto;
        user-select: text;
        caret-color: transparent;
        font-family: "Consolas", "Menlo", "SFMono-Regular", monospace;
        font-size: 0.78rem;
        line-height: 1.48;
        color: #b5ddff;
      }

      .terminal-prompt {
        border-top: 1px solid rgba(111, 194, 255, 0.24);
        padding: 8px 14px 10px;
        font-family: "Consolas", "Menlo", "SFMono-Regular", monospace;
        font-size: 0.8rem;
        color: var(--muted);
      }

      .api-line {
        color: #d4e4ff;
      }

      .api-line strong {
        color: #8ef0c8;
        font-weight: 600;
      }

      .terminal-link {
        color: #8ef0c8;
        text-decoration: underline;
      }

      .terminal-prompt::after {
        content: " _";
        animation: blinkCursor 1s steps(1, end) infinite;
      }

      .terminal-inline-loader {
        display: inline-flex;
        align-items: baseline;
        gap: 2px;
        color: #8ef0c8;
      }

      .terminal-inline-loader-dots {
        display: inline-block;
        width: 0;
        overflow: hidden;
        vertical-align: bottom;
        animation: terminalThinkingDots 1.2s steps(4, end) infinite;
      }

      .terminal-inline-loader-dots::before {
        content: "...";
      }

      .boot-line {
        opacity: 0;
        transform: translateY(5px);
        transition: opacity 220ms ease, transform 220ms ease;
      }

      .boot-line.show {
        opacity: 1;
        transform: translateY(0);
      }

      .boot-line strong {
        color: var(--accent-2);
        font-weight: 600;
      }

      .boot-line-loading {
        color: #8ef0c8;
      }

      .brain-core {
        position: absolute;
        left: 50%;
        top: 50%;
        width: min(56vw, 620px);
        aspect-ratio: 1.28;
        transform: translate(-50%, -50%) rotateX(var(--brain-tilt-x, 0deg)) rotateY(var(--brain-tilt-y, 0deg));
        transform-style: preserve-3d;
        transform-origin: center center;
        pointer-events: none;
        filter: drop-shadow(0 28px 42px rgba(0, 0, 0, 0.55)) drop-shadow(0 0 58px rgba(111, 194, 255, 0.25));
        transition: transform 140ms linear, opacity 520ms ease, filter 520ms ease;
        opacity: 1;
      }

      .starfield.intro-locked .terminal-dock {
        opacity: 1;
        transform: translateY(0);
        pointer-events: none;
      }

      .starfield.intro-locked,
      .starfield.intro-sinking,
      .starfield.map-active {
        display: grid;
        align-items: center;
      }

      .starfield.intro-locked .organism,
      .starfield.intro-sinking .organism,
      .starfield.map-active .organism {
        height: min(46vh, 430px);
      }

      .starfield.intro-locked .terminal {
        height: clamp(122px, 16vh, 148px);
      }

      .starfield.intro-locked .terminal-close {
        display: none;
      }

      .starfield.intro-locked .terminal-protocol-btn {
        pointer-events: none;
        opacity: 0.7;
      }

      .starfield.intro-locked .organism {
        opacity: 1;
        filter: blur(0);
      }

      .starfield.intro-sinking .organism,
      .starfield.map-active .organism {
        opacity: 1;
        filter: blur(0);
      }

      .starfield.intro-locked .brain-core {
        pointer-events: auto;
        cursor: pointer;
      }

      .starfield.intro-locked .brain-core:hover,
      .starfield.intro-locked .brain-core:focus-visible {
        filter: drop-shadow(0 32px 48px rgba(0, 0, 0, 0.58)) drop-shadow(0 0 72px rgba(111, 194, 255, 0.32));
        outline: none;
      }

      .starfield.intro-sinking .brain-core {
        transition: transform 620ms cubic-bezier(0.2, 0.84, 0.22, 1), opacity 460ms ease, filter 460ms ease, top 620ms cubic-bezier(0.2, 0.84, 0.22, 1);
        transform: translate(-50%, -50%) scale(0.84) rotateX(var(--brain-tilt-x, 0deg)) rotateY(var(--brain-tilt-y, 0deg));
        opacity: 0.72;
      }

      .starfield.map-active .brain-core {
        transform: translate(-50%, -50%) scale(0.84) rotateX(var(--brain-tilt-x, 0deg)) rotateY(var(--brain-tilt-y, 0deg));
        opacity: 0.86;
        pointer-events: auto;
        cursor: grab;
        filter: drop-shadow(0 10px 20px rgba(0, 0, 0, 0.45)) drop-shadow(0 0 26px rgba(111, 194, 255, 0.2));
      }

      .starfield.map-active .brain-core.is-dragging {
        cursor: grabbing;
      }

      .brain-viewport {
        position: absolute;
        inset: 0;
        z-index: 2;
        pointer-events: none;
      }

      .brain-shell,
      .brain-grid,
      .brain-wireframe {
        display: none;
      }

      .brain-shell,
      .brain-shell::before,
      .brain-shell::after {
        position: absolute;
        content: "";
      }

      .brain-shell {
        inset: 9% 5%;
        border-radius: 53% 47% 49% 51% / 61% 43% 57% 39%;
        border: 1px solid rgba(111, 194, 255, 0.45);
        background:
          radial-gradient(circle at 36% 34%, rgba(161, 217, 255, 0.34), rgba(18, 30, 54, 0.2) 34%, rgba(8, 14, 28, 0.9) 78%),
          linear-gradient(150deg, rgba(26, 42, 74, 0.55), rgba(9, 16, 30, 0.72));
        box-shadow:
          inset 0 0 36px rgba(111, 194, 255, 0.24),
          0 0 42px rgba(111, 194, 255, 0.3);
        animation: brainPulse 9.5s ease-in-out infinite;
      }

      .brain-shell::before {
        inset: 13% 9%;
        border-radius: 53% 47% 52% 48% / 60% 44% 56% 40%;
        border: 1px solid rgba(111, 194, 255, 0.3);
      }

      .brain-shell::after {
        inset: -8% -5%;
        border-radius: 54% 46% 50% 50% / 62% 42% 58% 38%;
        border: 1px solid rgba(224, 189, 114, 0.2);
      }

      .brain-grid {
        position: absolute;
        inset: 11% 7%;
        border-radius: 52% 48% 50% 50% / 62% 42% 58% 38%;
        background:
          linear-gradient(0deg, rgba(111, 194, 255, 0.16), rgba(111, 194, 255, 0.16)) 0 50% / 100% 1px no-repeat,
          repeating-linear-gradient(
            90deg,
            rgba(111, 194, 255, 0.13) 0px,
            rgba(111, 194, 255, 0.13) 1px,
            transparent 1px,
            transparent 14px
          ),
          repeating-linear-gradient(
            0deg,
            rgba(111, 194, 255, 0.1) 0px,
            rgba(111, 194, 255, 0.1) 1px,
            transparent 1px,
            transparent 12px
          );
        mix-blend-mode: screen;
        opacity: 0.54;
        animation: brainGridDrift 10s linear infinite;
      }

      .brain-wireframe {
        position: absolute;
        inset: 9% 4%;
        width: 92%;
        height: 82%;
        overflow: visible;
      }

      .brain-wireframe path {
        fill: none;
        stroke: rgba(140, 214, 255, 0.58);
        stroke-width: 1.8;
        stroke-linecap: round;
        stroke-linejoin: round;
        filter: drop-shadow(0 0 8px rgba(111, 194, 255, 0.26));
      }

      .brain-wireframe .brain-wireframe-accent {
        stroke: rgba(224, 189, 114, 0.42);
        stroke-width: 1.2;
      }

      @keyframes brainPulse {
        0%,
        100% {
          transform: scale(1);
          filter: brightness(0.97);
        }
        50% {
          transform: scale(1.015);
          filter: brightness(1.04);
        }
      }

      @keyframes brainGridDrift {
        0% {
          transform: translate3d(0, 0, 0);
        }
        100% {
          transform: translate3d(14px, -8px, 0);
        }
      }

      .star-node {
        position: absolute;
        left: 0;
        top: 0;
        width: 138px;
        transform: translate(-50%, -50%);
        display: grid;
        justify-items: center;
        gap: 8px;
        text-decoration: none;
        color: var(--text);
        z-index: 5;
        opacity: 0;
        pointer-events: none;
        transition: opacity 340ms ease;
      }

      .star-node.is-visible {
        opacity: 1;
        pointer-events: auto;
      }

      .star-node--ops {
        z-index: 6;
      }

      .star-sub-node {
        position: absolute;
        left: 0;
        top: 0;
        width: 124px;
        transform: translate(-50%, -50%);
        display: grid;
        justify-items: center;
        gap: 6px;
        text-decoration: none;
        color: var(--text);
        z-index: 7;
        opacity: 0;
        pointer-events: none;
        transition: opacity 220ms ease;
      }

      .star-sub-node .node-icon {
        width: 54px;
        height: 54px;
        border-radius: 15px;
      }

      .star-sub-node span {
        font-size: 0.64rem;
        padding: 3px 8px;
      }

      .node-icon {
        width: 66px;
        height: 66px;
        border-radius: 18px;
        border: 1px solid rgba(111, 194, 255, 0.54);
        background:
          radial-gradient(circle at 30% 24%, rgba(120, 180, 255, 0.3), rgba(20, 31, 52, 0.92)),
          linear-gradient(180deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0));
        display: grid;
        place-items: center;
        box-shadow:
          0 10px 26px rgba(0, 0, 0, 0.44),
          0 0 26px rgba(111, 194, 255, 0.34);
        transition: transform 140ms ease, box-shadow 140ms ease, border-color 140ms ease;
      }

      .star-node[data-kind="meta"] .node-icon {
        border-color: rgba(142, 240, 200, 0.6);
        box-shadow: 0 10px 26px rgba(0, 0, 0, 0.44), 0 0 26px rgba(142, 240, 200, 0.35);
      }

      .star-node[data-kind="core"] .node-icon {
        border-color: rgba(224, 189, 114, 0.72);
        box-shadow: 0 10px 26px rgba(0, 0, 0, 0.44), 0 0 26px rgba(224, 189, 114, 0.38);
      }

      .star-node svg {
        width: 40px;
        height: 40px;
        display: block;
      }

      .star-node span {
        display: inline-block;
        border: 1px solid rgba(83, 109, 165, 0.46);
        border-radius: 999px;
        padding: 4px 10px;
        background: rgba(13, 23, 44, 0.66);
        font-size: 0.72rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--muted);
      }

      .star-node:focus-visible,
      .star-node:hover {
        outline: none;
      }

      .star-node:focus-visible .node-icon,
      .star-node:hover .node-icon {
        transform: translateY(-4px) scale(1.04);
        border-color: rgba(224, 189, 114, 0.9);
        box-shadow:
          0 14px 34px rgba(0, 0, 0, 0.56),
          0 0 34px rgba(224, 189, 114, 0.52);
      }

      .star-node:focus-visible .node-icon {
        box-shadow:
          0 0 0 2px rgba(7, 13, 26, 0.96),
          0 0 0 4px rgba(224, 189, 114, 0.56),
          0 14px 34px rgba(0, 0, 0, 0.56),
          0 0 34px rgba(224, 189, 114, 0.52);
      }

      @keyframes blinkCursor {
        0%,
        49% {
          opacity: 1;
        }
        50%,
        100% {
          opacity: 0;
        }
      }

      @keyframes terminalThinkingDots {
        0% {
          width: 0;
        }
        100% {
          width: 1.2em;
        }
      }

      @media (max-width: 900px) {
        .cosmos-shell {
          padding: 10px;
        }

        .organism {
          height: min(88vh, 760px);
        }

        .brain-core {
          width: min(70vw, 460px);
        }

        .star-node {
          width: 108px;
          gap: 6px;
        }

        .node-icon {
          width: 56px;
          height: 56px;
          border-radius: 14px;
        }

        .star-node svg {
          width: 34px;
          height: 34px;
        }

        .star-node span {
          font-size: 0.66rem;
          padding: 3px 8px;
        }

        .star-sub-node {
          width: 96px;
        }

        .star-sub-node .node-icon {
          width: 46px;
          height: 46px;
          border-radius: 12px;
        }

        .star-sub-node span {
          font-size: 0.58rem;
          padding: 2px 7px;
        }
      }

      @media (max-height: 860px) {
        .organism {
          height: min(82vh, 720px);
        }

        .brain-core {
          width: min(52vw, 520px);
        }
      }

      @media (max-height: 760px) {
        .terminal {
          height: clamp(156px, 22vh, 190px);
        }

        .organism {
          height: min(84vh, 660px);
        }

        .brain-core {
          width: min(56vw, 460px);
        }
      }

      @media (max-width: 640px) {
        body {
          overflow: auto;
        }

        .organism {
          height: 740px;
        }

        .map-hud {
          top: 10px;
          left: 10px;
          right: 10px;
        }

        .chip {
          font-size: 0.64rem;
          padding: 6px 10px;
        }

        .terminal-dock {
          left: 10px;
          right: 10px;
          top: 10px;
          bottom: 10px;
        }

        .terminal-head {
          padding: 8px 10px;
          font-size: 0.66rem;
        }

        .terminal-body {
          font-size: 0.72rem;
          min-height: 0;
          padding: 9px 10px 7px;
        }

        .terminal-prompt {
          font-size: 0.72rem;
          padding: 7px 10px 8px;
        }
      }

      @media (prefers-reduced-motion: reduce) {
        *,
        *::before,
        *::after {
          animation-duration: 0.01ms !important;
          animation-iteration-count: 1 !important;
          transition-duration: 0.01ms !important;
        }
      }
    </style>
  </head>
  <body>
    <canvas id="depth-layer" aria-hidden="true"></canvas>
    <canvas id="lattice-layer" aria-hidden="true"></canvas>
    <div class="scan-noise" aria-hidden="true"></div>

    <main class="cosmos-shell">
      <section class="starfield intro-locked" aria-label="Star map launcher">
        <div class="terminal-dock" aria-live="polite">
          <div class="terminal">
            <div class="terminal-head">
              <span>Cognitive Navigation Terminal</span>
              <div class="terminal-head-actions">
                <button type="button" class="terminal-protocol-btn" id="protocol-link">Protocol NX-7A19.442</button>
                <button type="button" class="terminal-close" id="terminal-close-btn" aria-label="Expand terminal panel">^</button>
              </div>
            </div>
            <div class="terminal-body" id="boot-log"></div>
            <div class="terminal-prompt" id="terminal-status">searching // locating subject</div>
          </div>
        </div>

        <div class="map-hud">
          <div class="chip"><span class="chip-dot" aria-hidden="true"></span> brianz.dev lattice</div>
          <button type="button" class="chip chip-reset-btn" id="reboot-link" aria-label="Reboot interface" title="Reboot interface">
            <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
              <path d="M19 8A8 8 0 1 0 20 12" stroke="#8EF0C8" stroke-width="2" stroke-linecap="round"/>
              <path d="M20 4V9H15" stroke="#8EF0C8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
        </div>

        <div class="organism" id="organism">
          <div class="brain-core" id="brain-core" role="button" tabindex="0" aria-label="Enter neural map">
            <div class="brain-viewport" id="brain-viewport"></div>
            <div class="brain-shell"></div>
            <div class="brain-grid"></div>
            <svg class="brain-wireframe" viewBox="0 0 420 260" xmlns="http://www.w3.org/2000/svg">
              <path d="M40 142C52 88 106 56 168 58C196 44 222 42 249 51C318 54 366 92 377 145C366 196 314 228 248 225C219 237 191 238 164 229C103 226 53 194 40 142Z" />
              <path d="M88 96C127 89 155 94 173 112C191 93 220 88 259 94C278 110 286 129 283 151C282 175 271 192 249 203C214 210 190 208 173 196C153 208 129 211 99 203C76 191 65 173 65 148C60 127 68 109 88 96Z" />
              <path d="M77 140H128M133 110L162 128M168 92V126M212 86L196 127M238 99L212 132M269 120L224 142M133 176L168 158M197 158L235 178M258 170L286 188" />
              <path class="brain-wireframe-accent" d="M169 127C183 112 201 112 213 128M169 158C183 173 201 174 213 158M173 127V196M213 127V196" />
            </svg>
          </div>

          <a class="star-node star-node--primary" id="tftduos-link" data-kind="core" data-x="26" data-y="44" href="https://tftduos.brianz.dev" aria-label="Open TFT Duos Coach">
            <div class="node-icon">
              <svg viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M32 4L56 18V46L32 60L8 46V18L32 4Z" fill="#16223B" stroke="#E0BD72" stroke-width="2.4"/>
                <path d="M13 21H30V26H24V43H19V26H13V21Z" fill="#E0BD72"/>
                <path d="M31 21H50V26H43V43H38V26H31V21Z" fill="#E0BD72"/>
                <path d="M33 31H49V36H38V43H33V31Z" fill="#6FC2FF"/>
              </svg>
            </div>
            <span>TFT Duos</span>
          </a>

          <a class="star-node star-node--primary" id="memory-link" data-kind="meta" data-x="74" data-y="44" href="#" aria-label="Open subject memory access stream">
            <div class="node-icon">
              <svg viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
                <rect x="8" y="8" width="48" height="48" rx="12" fill="#12243A" stroke="#8EF0C8" stroke-width="2.2"/>
                <path d="M17 21H47M17 32H47M17 43H36" stroke="#8EF0C8" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
                <circle cx="45" cy="43" r="3" fill="#8EF0C8"/>
              </svg>
            </div>
            <span>Memory Access</span>
          </a>

          <a class="star-node star-node--primary" id="warhammer-link" data-kind="core" data-x="50" data-y="44" href="https://site-performance.brianz.dev" aria-label="Open Warhammer 40K companion app">
            <div class="node-icon">
              <svg viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
                <rect x="8" y="8" width="48" height="48" rx="12" fill="#121f35" stroke="#E0BD72" stroke-width="2.2"/>
                <path d="M18 22L32 18L46 22L43 41L32 46L21 41L18 22Z" fill="#16223B" stroke="#E0BD72" stroke-width="2"/>
                <path d="M23 31H27L29 37L32 25L35 37L37 31H41" stroke="#E0BD72" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </div>
            <span>Warhammer</span>
          </a>

          <a class="star-node star-node--primary" data-x="38" data-y="74" href="https://github.com/bziebart123/brianz.dev" aria-label="Open GitHub Repository">
            <div class="node-icon">
              <svg viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
                <rect x="9" y="9" width="46" height="46" rx="12" fill="#121f35" stroke="#E0BD72" stroke-width="2.2"/>
                <path d="M23 42V24H41V42" stroke="#E0BD72" stroke-width="3" stroke-linejoin="round"/>
                <path d="M20 28L32 18L44 28" stroke="#E0BD72" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </div>
            <span>Source</span>
          </a>

          <a class="star-node star-node--primary" id="contact-link" data-kind="meta" data-x="62" data-y="74" href="#" aria-label="Open contact relay">
            <div class="node-icon">
              <svg viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
                <rect x="10" y="14" width="44" height="36" rx="8" fill="#13223A" stroke="#8EF0C8" stroke-width="2.2"/>
                <path d="M14 19L32 34L50 19" stroke="#8EF0C8" stroke-width="2.8" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </div>
            <span>Contact</span>
          </a>
        </div>

      </section>
    </main>

    <script type="module">
      import * as THREE from "./vendor/three.module.min.js";
      import { GLTFLoader } from "./vendor/GLTFLoader.js";

      (function () {
        var host = window.location.hostname;
        var isLocal = host === "localhost" || host === "127.0.0.1";

        var tftLink = document.getElementById("tftduos-link");
        var warhammerLink = document.getElementById("warhammer-link");
        var memoryLink = document.getElementById("memory-link");
        var opsLink = document.getElementById("ops-link");
        var metaLink = document.getElementById("meta-link");
        var backendLink = document.getElementById("backend-link");
        var contactLink = document.getElementById("contact-link");
        var starfield = document.querySelector(".starfield");
        var terminalDock = document.querySelector(".terminal-dock");
        var terminalPanel = document.querySelector(".terminal");
        var mapHud = document.querySelector(".map-hud");
        var rebootLink = document.getElementById("reboot-link");
        var protocolLink = document.getElementById("protocol-link");
        var bootLog = document.getElementById("boot-log");
        var terminalStatus = document.getElementById("terminal-status");
        var terminalCloseBtn = document.getElementById("terminal-close-btn");
        var terminalExpanded = false;
        var terminalMode = "sync";
        var backendRequestCount = 0;
        var renderMetaRequestCount = 0;
        var contactRequestCount = 0;
        var terminalQueueOffset = 0;
        var renderMetaChain = Promise.resolve();
        var systemAccessMode = "memory";
        var terminalOutputLoadingLine = null;
        var linkedinUrl = "https://www.linkedin.com/in/brian-ziebart/";
        var uiSfxContext = null;
        var uiSfxUnlocked = false;
        var uiSfxLastAt = 0;
        var uiSfxElementAt = new WeakMap();
        var subAppHosts = [
          "tftduos.brianz.dev",
          "site-performance.brianz.dev",
          "localhost:4173",
          "localhost:4174",
          "127.0.0.1:4173",
          "127.0.0.1:4174"
        ];

        if (isLocal) {
          if (tftLink) tftLink.setAttribute("href", "http://localhost:4173");
          if (warhammerLink) warhammerLink.setAttribute("href", "http://localhost:4174");
          if (metaLink) metaLink.setAttribute("href", "http://localhost:3001/api/site-performance/render/overview?hours=24");
        } else {
          if (tftLink) tftLink.setAttribute("href", "https://tftduos.brianz.dev");
          if (warhammerLink) warhammerLink.setAttribute("href", "https://site-performance.brianz.dev");
          if (metaLink) metaLink.setAttribute("href", "https://api.brianz.dev/api/site-performance/render/overview?hours=24");
        }

        var organism = document.getElementById("organism");
        var brainCore = document.getElementById("brain-core");
        var brainViewport = document.getElementById("brain-viewport");
        var nodes = Array.prototype.slice.call(document.querySelectorAll(".star-node--primary"));
        var opsSubNodes = Array.prototype.slice.call(document.querySelectorAll(".star-sub-node"));
        var nodeState = [];
        var opsAnchorState = null;
        var opsExpanded = false;
        var opsExpandProgress = 0;
        var opsCollapseTimer = null;
        var brainTiltX = 0;
        var brainTiltY = 0;
        var brainSpinRadians = 0;
        var brainLoadStartMs = (window.performance && typeof window.performance.now === "function") ? window.performance.now() : Date.now();
        var brainDragActive = false;
        var brainDragPointerId = null;
        var brainUserRotX = 0;
        var brainUserRotY = 0;
        var brainScene = null;
        var brainCamera = null;
        var brainRenderer = null;
        var brainRoot = null;
        var brainModelGroup = null;
        var latticePulseLines = [];
        var nodeAnimationStarted = false;
        var latticeLoopStarted = false;
        var introTransitionActive = false;
        var mapActivated = false;
        var brainDockedY = null;
        var brainShakeMeter = 0;
        var brainShakeSessionEnergy = 0;
        var brainShakeMildIssued = false;
        var brainShakeStrongIssued = false;
        var brainShakeAlertUntil = 0;
        var brainShakeMildCooldownUntil = 0;
        var brainShakeStrongCooldownUntil = 0;
        var subjectAlertLevel = 0;
        var subjectAlertTarget = 0;
        var subjectAlertLastMotionAt = 0;

        nodes.forEach(function (node) {
          node.removeAttribute("target");
          node.removeAttribute("rel");
        });

        if (backendLink) {
          backendLink.removeAttribute("target");
          backendLink.removeAttribute("rel");
        }
        if (metaLink) {
          metaLink.removeAttribute("target");
          metaLink.removeAttribute("rel");
        }
        if (opsLink) {
          opsLink.removeAttribute("target");
          opsLink.removeAttribute("rel");
        }

        setOpsExpanded(false);

        function ensureUiSfxContext() {
          if (!uiSfxContext) {
            var AudioCtx = window.AudioContext || window.webkitAudioContext;
            if (!AudioCtx) return null;
            uiSfxContext = new AudioCtx();
          }
          return uiSfxContext;
        }

        function unlockUiSfx() {
          var ctx = ensureUiSfxContext();
          if (!ctx) return;
          if (ctx.state === "suspended") {
            ctx.resume().catch(function () {});
          }
          uiSfxUnlocked = true;
        }

        function playUiClickSfx(variant) {
          var ctx = ensureUiSfxContext();
          if (!ctx || !uiSfxUnlocked) return;
          if (ctx.state === "suspended") {
            ctx.resume().catch(function () {});
          }
          var now = ctx.currentTime;
          var oscA = ctx.createOscillator();
          var oscB = ctx.createOscillator();
          var gain = ctx.createGain();
          var filter = ctx.createBiquadFilter();
          var isPress = variant === "press";

          // E profile (Tight Dual) from sfx-lab, with slightly hotter press accent.
          oscA.type = "square";
          oscA.frequency.setValueAtTime(isPress ? 2020 : 1900, now);
          oscA.frequency.exponentialRampToValueAtTime(isPress ? 1310 : 1290, now + 0.011);

          oscB.type = "triangle";
          oscB.frequency.setValueAtTime(isPress ? 3040 : 2920, now);
          oscB.frequency.exponentialRampToValueAtTime(isPress ? 1820 : 1810, now + 0.009);

          gain.gain.setValueAtTime(0.0001, now);
          gain.gain.exponentialRampToValueAtTime(isPress ? 0.021 : 0.0175, now + 0.0012);
          gain.gain.exponentialRampToValueAtTime(0.0001, now + (isPress ? 0.021 : 0.018));

          filter.type = "highpass";
          filter.frequency.setValueAtTime(isPress ? 1360 : 1300, now);
          filter.Q.setValueAtTime(0.45, now);

          oscA.connect(filter);
          oscB.connect(filter);
          filter.connect(gain);
          gain.connect(ctx.destination);

          oscA.start(now);
          oscB.start(now);
          oscA.stop(now + (isPress ? 0.024 : 0.021));
          oscB.stop(now + (isPress ? 0.02 : 0.018));
        }

        function bindUiSfxToInteractive() {
          var interactive = Array.prototype.slice.call(document.querySelectorAll("a, button, [role=\"button\"]")).filter(function (el) {
            return !el.classList.contains("star-node");
          });
          interactive.forEach(function (el) {
            var triggerHover = function () {
              if (!el || el.hasAttribute("disabled") || el.getAttribute("aria-hidden") === "true") return;
              var nowMs = Date.now();
              var lastForElement = Number(uiSfxElementAt.get(el) || 0);
              if (nowMs - lastForElement < 120) return;
              if (nowMs - uiSfxLastAt < 50) return;
              uiSfxElementAt.set(el, nowMs);
              uiSfxLastAt = nowMs;
              playUiClickSfx("hover");
            };
            var triggerPress = function () {
              if (!el || el.hasAttribute("disabled") || el.getAttribute("aria-hidden") === "true") return;
              var nowMs = Date.now();
              if (nowMs - uiSfxLastAt < 36) return;
              uiSfxElementAt.set(el, nowMs);
              uiSfxLastAt = nowMs;
              playUiClickSfx("press");
            };
            el.addEventListener("pointerenter", triggerHover);
            el.addEventListener("focus", triggerHover);
            el.addEventListener("click", triggerPress);
          });

          // Star-node sounds should trigger from the visible icon hotspot, not padded node bounds.
          var starNodes = Array.prototype.slice.call(document.querySelectorAll(".star-node"));
          starNodes.forEach(function (node) {
            var icon = node.querySelector(".node-icon");
            if (!icon) return;

            var triggerHover = function () {
              if (!node || node.hasAttribute("disabled") || node.getAttribute("aria-hidden") === "true") return;
              var nowMs = Date.now();
              var lastForElement = Number(uiSfxElementAt.get(node) || 0);
              if (nowMs - lastForElement < 120) return;
              if (nowMs - uiSfxLastAt < 50) return;
              uiSfxElementAt.set(node, nowMs);
              uiSfxLastAt = nowMs;
              playUiClickSfx("hover");
            };
            var triggerPress = function () {
              if (!node || node.hasAttribute("disabled") || node.getAttribute("aria-hidden") === "true") return;
              var nowMs = Date.now();
              if (nowMs - uiSfxLastAt < 36) return;
              uiSfxElementAt.set(node, nowMs);
              uiSfxLastAt = nowMs;
              playUiClickSfx("press");
            };

            icon.addEventListener("pointerenter", triggerHover);
            icon.addEventListener("click", triggerPress);
            node.addEventListener("focus", triggerHover);
          });
        }

        window.addEventListener("pointerdown", unlockUiSfx, { once: true });
        window.addEventListener("keydown", unlockUiSfx, { once: true });
        bindUiSfxToInteractive();

        initThreeBrain();
        resizeBrainViewport();

        if (opsLink) {
          opsLink.addEventListener("mouseenter", function () {
            cancelOpsCollapse();
            setOpsExpanded(true);
          });
          opsLink.addEventListener("focus", function () {
            cancelOpsCollapse();
            setOpsExpanded(true);
          });
          opsLink.addEventListener("mouseleave", scheduleOpsCollapse);
          opsLink.addEventListener("blur", scheduleOpsCollapse);
          opsLink.addEventListener("click", function (event) {
            if (event.metaKey || event.ctrlKey || event.shiftKey || event.altKey) return;
            event.preventDefault();
            setOpsExpanded(!opsExpanded);
          });
        }

        opsSubNodes.forEach(function (subNode) {
          subNode.addEventListener("mouseenter", function () {
            cancelOpsCollapse();
            setOpsExpanded(true);
          });
          subNode.addEventListener("focus", function () {
            cancelOpsCollapse();
            setOpsExpanded(true);
          });
          subNode.addEventListener("mouseleave", scheduleOpsCollapse);
          subNode.addEventListener("blur", scheduleOpsCollapse);
        });

        document.addEventListener("pointerdown", function (event) {
          var target = event.target;
          if (!opsLink && !opsSubNodes.length) return;
          if (opsLink && opsLink.contains(target)) return;
          for (var i = 0; i < opsSubNodes.length; i += 1) {
            if (opsSubNodes[i].contains(target)) return;
          }
          setOpsExpanded(false);
        });

        function pushBootLine(text, isHighlight) {
          if (!bootLog) return;
          var line = document.createElement("div");
          line.className = "boot-line";
          line.innerHTML = isHighlight ? "<strong>" + text + "</strong>" : text;
          bootLog.appendChild(line);
          requestAnimationFrame(function () {
            line.classList.add("show");
          });
        }

        function pushBootLineHtml(html, className) {
          if (!bootLog) return;
          var line = document.createElement("div");
          line.className = "boot-line" + (className ? " " + className : "");
          line.innerHTML = html;
          bootLog.appendChild(line);
          requestAnimationFrame(function () {
            line.classList.add("show");
          });
        }

        function setTerminalStatusText(text, thinking) {
          if (!terminalStatus) return;
          terminalStatus.textContent = text;
        }

        function signalBrainShakeWarning(level) {
          var nowMs = Date.now();
          var isStrong = level === "strong";
          if (isStrong) {
            if (nowMs < brainShakeStrongCooldownUntil) return;
            brainShakeStrongCooldownUntil = nowMs + 12000;
          } else {
            if (nowMs < brainShakeMildCooldownUntil) return;
            brainShakeMildCooldownUntil = nowMs + 9000;
          }
          brainShakeAlertUntil = nowMs + (isStrong ? 11500 : 9000);
          if (isStrong) {
            pushBootLine("> Critical Warning: neural stress spike detected. stabilize the subject immediately.", true);
            setTerminalStatusText("critical // subject stability compromised", false);
            subjectAlertTarget = 1;
            subjectAlertLastMotionAt = nowMs;
          } else {
            pushBootLine("> Warning: be careful with the subject.", true);
            setTerminalStatusText("warning // subject stability at risk", false);
          }
          setTimeout(function () {
            if (Date.now() < brainShakeAlertUntil) return;
            setTerminalStatusText("terminal synced // node lattice online", false);
          }, isStrong ? 3200 : 2200);
        }

        function setTerminalOutputLoading(text) {
          if (!bootLog) return;
          if (terminalOutputLoadingLine && terminalOutputLoadingLine.parentNode) {
            terminalOutputLoadingLine.parentNode.removeChild(terminalOutputLoadingLine);
          }
          terminalOutputLoadingLine = null;
          if (!text) return;
          var line = document.createElement("div");
          line.className = "boot-line boot-line-loading show";
          line.innerHTML = text + " <span class=\"terminal-inline-loader\" aria-hidden=\"true\"><span class=\"terminal-inline-loader-dots\"></span></span>";
          bootLog.appendChild(line);
          terminalOutputLoadingLine = line;
          bootLog.scrollTop = bootLog.scrollHeight;
        }

        function syncTerminalToggleControl() {
          if (!terminalCloseBtn) return;
          var isExpanded = !!terminalExpanded;
          terminalCloseBtn.textContent = isExpanded ? "v" : "^";
          terminalCloseBtn.setAttribute("aria-label", isExpanded ? "Collapse terminal panel" : "Expand terminal panel");
          terminalCloseBtn.setAttribute("title", isExpanded ? "Collapse terminal panel" : "Expand terminal panel");
        }

        function beginSubjectMemoryAccess(mode) {
          systemAccessMode = mode === "protocol" ? "protocol" : "memory";
          if (!terminalExpanded) setTerminalExpanded(true);
          if (systemAccessMode === "protocol") {
            renderMetaChain = renderMetaChain.then(function () {
              return appendRenderMetaSnapshot();
            }).catch(function () {
              return appendRenderMetaSnapshot();
            });
            return;
          }
          appendApiManifest();
          if (bootLog) bootLog.scrollTop = bootLog.scrollHeight;
        }

        function applyTerminalModeStatus() {
          if (terminalMode === "data") {
            setTerminalStatusText("terminal data mode // esc or close to collapse", false);
            return;
          }
          if (terminalMode === "contact") {
            setTerminalStatusText("contact relay mode // esc or close to collapse", false);
            return;
          }
          setTerminalStatusText("terminal synced // node lattice online", false);
        }

        setTerminalStatusText("searching // locating subject", true);

        function setOpsExpanded(expanded) {
          opsExpanded = !!expanded;
          if (opsLink) {
            opsLink.setAttribute("aria-expanded", opsExpanded ? "true" : "false");
          }
        }

        function cancelOpsCollapse() {
          if (opsCollapseTimer) {
            window.clearTimeout(opsCollapseTimer);
            opsCollapseTimer = null;
          }
        }

        function scheduleOpsCollapse() {
          cancelOpsCollapse();
          opsCollapseTimer = window.setTimeout(function () {
            setOpsExpanded(false);
          }, 220);
        }

        function buildFallbackBrainMesh() {
          if (!THREE) return null;
          var group = new THREE.Group();
          var material = new THREE.MeshStandardMaterial({
            color: 0x6fc2ff,
            emissive: 0x1f5a88,
            emissiveIntensity: 0.9,
            roughness: 0.55,
            metalness: 0.22,
            transparent: true,
            opacity: 0.9
          });
          var leftGeo = new THREE.IcosahedronGeometry(0.9, 4);
          var rightGeo = new THREE.IcosahedronGeometry(0.9, 4);
          leftGeo.scale(0.98, 0.92, 0.74);
          rightGeo.scale(0.98, 0.92, 0.74);
          var left = new THREE.Mesh(leftGeo, material);
          var right = new THREE.Mesh(rightGeo, material);
          left.position.x = -0.55;
          right.position.x = 0.55;
          group.add(left);
          group.add(right);

          var wireMat = new THREE.LineBasicMaterial({ color: 0xaadfff, transparent: true, opacity: 0.5 });
          var leftEdges = new THREE.LineSegments(new THREE.EdgesGeometry(leftGeo, 16), wireMat);
          var rightEdges = new THREE.LineSegments(new THREE.EdgesGeometry(rightGeo, 16), wireMat);
          leftEdges.position.x = -0.55;
          rightEdges.position.x = 0.55;
          group.add(leftEdges);
          group.add(rightEdges);
          return group;
        }

        function styleLoadedBrain(rootModel) {
          if (!THREE || !rootModel) return;
          rootModel.traverse(function (child) {
            if (!child || !child.isMesh) return;
            var sourceMaterial = child.material;
            var materials = Array.isArray(sourceMaterial) ? sourceMaterial : [sourceMaterial];
            var tuned = materials.map(function (mat) {
              if (!mat || typeof mat.clone !== "function") {
                return new THREE.MeshStandardMaterial({
                  color: 0x83c7ff,
                  transparent: true,
                  opacity: 0.72,
                  roughness: 0.3,
                  metalness: 0.08,
                  emissive: 0x0f3560,
                  emissiveIntensity: 0.22
                });
              }
              var next = mat.clone();
              if (next.color && typeof next.color.lerp === "function") {
                next.color.lerp(new THREE.Color(0x8dcfff), 0.34);
              }
              next.transparent = true;
              next.opacity = Math.min(0.8, Math.max(0.66, Number(next.opacity || 1) * 0.82));
              next.depthWrite = true;
              next.depthTest = true;
              next.alphaTest = 0.01;
              next.side = THREE.DoubleSide;
              if ("roughness" in next) next.roughness = Math.max(0.2, Number(next.roughness || 0.45) * 0.72);
              if ("metalness" in next) next.metalness = Math.min(0.22, Number(next.metalness || 0) + 0.06);
              if ("transmission" in next) next.transmission = 0;
              if ("thickness" in next) next.thickness = 0;
              if ("emissiveIntensity" in next) next.emissiveIntensity = Math.max(0.14, Number(next.emissiveIntensity || 0) + 0.14);
              return next;
            });
            child.material = Array.isArray(sourceMaterial) ? tuned : tuned[0];
          });
          var box = new THREE.Box3().setFromObject(rootModel);
          var size = new THREE.Vector3();
          box.getSize(size);
          var maxAxis = Math.max(size.x, size.y, size.z) || 1;
          var scale = 2.45 / maxAxis;
          rootModel.scale.setScalar(scale);
          box.setFromObject(rootModel);
          var center = new THREE.Vector3();
          box.getCenter(center);
          rootModel.position.sub(center);
        }

        function alignBrainToViewport(rootModel) {
          if (!THREE || !rootModel || !brainCamera) return;
          brainCamera.updateProjectionMatrix();
          brainCamera.updateMatrixWorld();

          function projectedSilhouetteCenter(model) {
            var minX = Infinity;
            var maxX = -Infinity;
            var minY = Infinity;
            var maxY = -Infinity;
            var sumX = 0;
            var sumY = 0;
            var count = 0;
            var hasPoint = false;
            var worldPos = new THREE.Vector3();
            var ndcPos = new THREE.Vector3();

            model.traverse(function (node) {
              if (!node || !node.isMesh || !node.geometry) return;
              var posAttr = node.geometry.getAttribute && node.geometry.getAttribute("position");
              if (!posAttr || !posAttr.count) return;
              var step = Math.max(1, Math.ceil(posAttr.count / 2200));
              for (var idx = 0; idx < posAttr.count; idx += step) {
                worldPos.fromBufferAttribute(posAttr, idx);
                worldPos.applyMatrix4(node.matrixWorld);
                ndcPos.copy(worldPos).project(brainCamera);
                if (ndcPos.z < -1 || ndcPos.z > 1) continue;
                if (ndcPos.x < minX) minX = ndcPos.x;
                if (ndcPos.x > maxX) maxX = ndcPos.x;
                if (ndcPos.y < minY) minY = ndcPos.y;
                if (ndcPos.y > maxY) maxY = ndcPos.y;
                sumX += ndcPos.x;
                sumY += ndcPos.y;
                count += 1;
                hasPoint = true;
              }
            });

            if (!hasPoint) return null;
            var avgX = sumX / Math.max(1, count);
            var avgY = sumY / Math.max(1, count);
            return {
              // Blend centroid + bounds midpoint for stable visual centering.
              x: (avgX * 0.75) + (((minX + maxX) * 0.5) * 0.25),
              y: (avgY * 0.75) + (((minY + maxY) * 0.5) * 0.25)
            };
          }

          var targetNdcX = -0.36;
          var targetNdcY = 0.0;
          for (var i = 0; i < 7; i += 1) {
            rootModel.updateMatrixWorld(true);
            var bounds = new THREE.Box3().setFromObject(rootModel);
            var size = new THREE.Vector3();
            bounds.getSize(size);

            var focus = new THREE.Vector3(
              (bounds.min.x + bounds.max.x) * 0.5,
              bounds.min.y + size.y * 0.69,
              (bounds.min.z + bounds.max.z) * 0.5
            );
            var silhouetteCenter = projectedSilhouetteCenter(rootModel);
            var ndc = silhouetteCenter || focus.clone().project(brainCamera);
            var focusCam = focus.clone().applyMatrix4(brainCamera.matrixWorldInverse);
            var depth = Math.max(0.001, -focusCam.z);
            var fovRad = (brainCamera.fov * Math.PI) / 180;
            var worldPerNdcY = depth * Math.tan(fovRad * 0.5);
            var worldPerNdcX = worldPerNdcY * brainCamera.aspect;

            var dxCam = (targetNdcX - ndc.x) * worldPerNdcX;
            var dyCam = (targetNdcY - ndc.y) * worldPerNdcY;
            var deltaWorld = new THREE.Vector3(dxCam, dyCam, 0).applyQuaternion(brainCamera.quaternion);
            rootModel.position.add(deltaWorld.multiplyScalar(1.2));
          }
        }

        function attachBrainModel(group) {
          if (!brainRoot || !group) return;
          if (brainModelGroup) {
            brainRoot.remove(brainModelGroup);
          }
          brainModelGroup = group;
          brainRoot.add(group);
          brainLoadStartMs = (window.performance && typeof window.performance.now === "function") ? window.performance.now() : Date.now();
          if (brainCore) brainCore.classList.add("is-3d-ready");
        }

        function initThreeBrain() {
          if (!brainViewport || !THREE) return;
          if (brainRenderer) return;

          brainScene = new THREE.Scene();
          brainCamera = new THREE.PerspectiveCamera(42, 1, 0.1, 100);
          brainCamera.position.set(0, 0.06, 5.1);

          brainRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
          brainRenderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
          brainRenderer.setClearColor(0x000000, 0);
          brainViewport.appendChild(brainRenderer.domElement);

          var ambient = new THREE.AmbientLight(0x7bbcff, 0.95);
          brainScene.add(ambient);
          var key = new THREE.DirectionalLight(0x92d8ff, 1.15);
          key.position.set(2.7, 2.1, 3.5);
          brainScene.add(key);
          var rim = new THREE.DirectionalLight(0xe0bd72, 0.68);
          rim.position.set(-2.2, -1.4, -2.5);
          brainScene.add(rim);

          brainRoot = new THREE.Group();
          brainScene.add(brainRoot);

          if (GLTFLoader) {
            var loader = new GLTFLoader();
            loader.load(
              "./assets/brainstem.glb",
              function (gltf) {
                var group = gltf && gltf.scene ? gltf.scene : null;
                if (!group) {
                  setTerminalStatusText("subject signal unavailable", false);
                  return;
                }
                styleLoadedBrain(group);
                attachBrainModel(group);
                setTerminalStatusText("subject acquired // neural map ready", false);
              },
              undefined,
              function () {
                setTerminalStatusText("subject signal unavailable", false);
              }
            );
          }
        }

        function resizeBrainViewport() {
          if (!brainRenderer || !brainViewport || !brainCamera) return;
          var w = Math.max(1, Math.floor(brainViewport.clientWidth));
          var h = Math.max(1, Math.floor(brainViewport.clientHeight));
          brainRenderer.setSize(w, h, false);
          brainCamera.aspect = w / h;
          brainCamera.updateProjectionMatrix();
        }

        function renderThreeBrain(timeSec) {
          if (!brainRenderer || !brainScene || !brainCamera || !brainRoot) return;
          var spinRate = (Math.PI * 2) / 28;
          brainSpinRadians = (timeSec * spinRate) % (Math.PI * 2);
          brainRoot.position.set(0, 0, 0);
          var userRotXRad = (brainUserRotX * Math.PI) / 180;
          var userRotYRad = (brainUserRotY * Math.PI) / 180;
          brainRoot.rotation.x = userRotXRad;
          brainRoot.rotation.y = brainSpinRadians + userRotYRad;
          brainRoot.rotation.z = 0;

          var nowMs = (window.performance && typeof window.performance.now === "function") ? window.performance.now() : Date.now();
          var introProgress = Math.max(0, Math.min(1, (nowMs - brainLoadStartMs) / 620));
          var introEase = 1 - Math.pow(1 - introProgress, 3);
          var introScale = 0.06 + (introEase * 0.94);

          brainRoot.scale.set(introScale, introScale, introScale);
          brainRenderer.render(brainScene, brainCamera);
        }

        function queueTerminalLine(index, delayMs, fn) {
          window.setTimeout(function () {
            fn();
            if (bootLog) bootLog.scrollTop = bootLog.scrollHeight;
          }, terminalQueueOffset + (delayMs * index));
        }

        function beginStarMap() {
          if (mapActivated) return;
          mapActivated = true;
          terminalMode = "sync";
          applyTerminalModeStatus();
          if (starfield) starfield.classList.add("ready");

          nodes.forEach(function (node, index) {
            window.setTimeout(function () {
              node.classList.add("is-visible");
            }, index * 150);
          });

          nodeAnimationStarted = true;
          updateNodeLayout();
        }

        function runBootSequenceAfterEntry(shouldSkipBoot, bootSequence) {
          if (shouldSkipBoot) {
            bootSequence.forEach(function (line) {
              pushBootLine(line.text, line.highlight);
            });
            beginStarMap();
            return;
          }

          bootSequence.forEach(function (line, index) {
            window.setTimeout(function () {
              pushBootLine(line.text, line.highlight);
              if (bootLog) {
                bootLog.scrollTop = bootLog.scrollHeight;
              }
            }, 180 + index * 420);
          });

          window.setTimeout(function () {
            beginStarMap();
          }, 180 + bootSequence.length * 420 + 300);
        }

        function triggerBrainEntry(shouldSkipBoot, bootSequence) {
          if (introTransitionActive || mapActivated) return;
          introTransitionActive = true;
          if (starfield) {
            starfield.classList.add("intro-sinking");
          }
          updateNodeLayout();
          window.setTimeout(function () {
            if (starfield) {
              starfield.classList.remove("intro-locked");
              starfield.classList.add("map-active");
            }
            introTransitionActive = false;
            runBootSequenceAfterEntry(shouldSkipBoot, bootSequence);
          }, 700);
        }

        function appendApiManifest() {
          if (!bootLog) return;
          backendRequestCount += 1;
          var backendBase = isLocal ? "http://localhost:3001" : "https://api.brianz.dev";
          var now = new Date();
          var hh = String(now.getHours()).padStart(2, "0");
          var mm = String(now.getMinutes()).padStart(2, "0");
          var ss = String(now.getSeconds()).padStart(2, "0");
          var stamp = hh + ":" + mm + ":" + ss;
          var routes = [
            { method: "GET", path: "/health", note: "Service heartbeat" },
            { method: "GET", path: "/api/tft/duo-history", note: "Duo match ingest + normalized payload" },
            { method: "GET", path: "/api/tft/icon-manifest", note: "Trait/champion icon index" },
            { method: "GET", path: "/api/tft/companion-manifest", note: "Companion/banner manifest" },
            { method: "POST", path: "/api/duo/events/batch", note: "Batch event ingest" },
            { method: "POST", path: "/api/duo/journal", note: "Duo coaching journal ingest" },
            { method: "GET", path: "/api/duo/scorecard", note: "Duo scorecard metrics" },
            { method: "GET", path: "/api/duo/playbook", note: "Deterministic playbook output" },
            { method: "GET", path: "/api/duo/highlights", note: "Highlight rollups" },
            { method: "POST", path: "/api/coach/llm-brief", note: "GPT coaching synthesis" },
            { method: "GET", path: "/api/site-performance/render/overview", note: "Render service overview" }
          ];
          var routeMethodWidth = routes.reduce(function (max, route) {
            return Math.max(max, String(route.method || "").length);
          }, 0);
          var routePathWidth = routes.reduce(function (max, route) {
            return Math.max(max, String(route.path || "").length);
          }, 0);

          var delay = 170;
          var cursor = 0;
          setTerminalOutputLoading("> processing api manifest");
          queueTerminalLine(cursor, delay, function () {
            pushBootLine("> Subject memory access accepted [" + stamp + "] #" + backendRequestCount, true);
          });
          cursor += 1;
          queueTerminalLine(cursor, delay, function () {
            pushBootLineHtml("&gt; run subject.memory.access --scope api-manifest --origin \"" + backendBase + "\"", "api-line");
          });
          cursor += 1;
          queueTerminalLine(cursor, delay, function () {
            pushBootLine("> Memory channel: connected API routes @ " + backendBase, false);
          });
          cursor += 1;
          routes.forEach(function (route) {
            queueTerminalLine(cursor, delay, function () {
              var methodColumn = String(route.method || "").toUpperCase().padEnd(routeMethodWidth, " ");
              var pathColumn = String(route.path || "").padEnd(routePathWidth, " ");
              pushBootLineHtml(
                "&gt; <strong>[" + methodColumn + "]</strong> " + pathColumn + "  // " + route.note,
                "api-line"
              );
            });
            cursor += 1;
          });
          queueTerminalLine(cursor, delay, function () {
            pushBootLine("> Press ESC or tap Close to collapse terminal view", false);
            setTerminalOutputLoading("");
          });
          terminalQueueOffset += (cursor + 1) * delay;
        }

        function setTerminalExpanded(expanded) {
          terminalExpanded = expanded;
          if (terminalDock) {
            terminalDock.classList.toggle("expanded", expanded);
          }
          terminalMode = expanded ? "data" : "sync";
          applyTerminalModeStatus();
          syncTerminalToggleControl();
        }

        function setContactTerminalExpanded(expanded) {
          terminalExpanded = expanded;
          if (terminalDock) {
            terminalDock.classList.toggle("expanded", expanded);
          }
          terminalMode = expanded ? "contact" : "sync";
          applyTerminalModeStatus();
          syncTerminalToggleControl();
        }

        function beginContactRelay() {
          contactRequestCount += 1;
          var delay = 170;
          var cursor = 0;
          var now = new Date();
          var hh = String(now.getHours()).padStart(2, "0");
          var mm = String(now.getMinutes()).padStart(2, "0");
          var ss = String(now.getSeconds()).padStart(2, "0");
          var stamp = hh + ":" + mm + ":" + ss;

          queueTerminalLine(cursor, delay, function () {
            pushBootLine("> Contact relay engaged [" + stamp + "] #" + contactRequestCount, true);
          });
          cursor += 1;
          queueTerminalLine(cursor, delay, function () {
            pushBootLineHtml("&gt; run contact.relay --channel linkedin", "api-line");
          });
          cursor += 1;
          queueTerminalLine(cursor, delay, function () {
            pushBootLine("> Public contact route ready", false);
          });
          cursor += 1;
          queueTerminalLine(cursor, delay, function () {
            pushBootLineHtml("&gt; <strong>[LINKEDIN]</strong> <a class=\"terminal-link\" href=\"" + linkedinUrl + "\" target=\"_blank\" rel=\"noopener noreferrer\">Open subject LinkedIn</a>", "api-line");
          });
          cursor += 1;
          queueTerminalLine(cursor, delay, function () {
            pushBootLine("> Email relay disabled for public privacy", false);
          });
          cursor += 1;
          queueTerminalLine(cursor, delay, function () {
            pushBootLine("> Press ESC or tap Close to collapse terminal view", false);
          });

          terminalQueueOffset += (cursor + 1) * delay;
        }

        if (backendLink) {
          backendLink.addEventListener("click", function (event) {
            if (event.metaKey || event.ctrlKey || event.shiftKey || event.altKey) return;
            event.preventDefault();
            if (!terminalExpanded) setTerminalExpanded(true);
            appendApiManifest();
            if (bootLog) bootLog.scrollTop = bootLog.scrollHeight;
          });
        }

        function formatNumber(value) {
          var n = Number(value || 0);
          if (!Number.isFinite(n)) return "-";
          return n.toLocaleString();
        }

        function formatPercent(value) {
          var n = Number(value || 0);
          if (!Number.isFinite(n)) return "-";
          return n.toFixed(2) + "%";
        }

        function formatBytes(value) {
          var n = Number(value || 0);
          if (!Number.isFinite(n) || n <= 0) return "0 B";
          var units = ["B", "KB", "MB", "GB", "TB"];
          var i = Math.min(Math.floor(Math.log(n) / Math.log(1024)), units.length - 1);
          var scaled = n / Math.pow(1024, i);
          var precision = scaled >= 10 || i === 0 ? 0 : 2;
          return scaled.toFixed(precision) + " " + units[i];
        }

        function formatDate(value) {
          var ms = Date.parse(String(value || ""));
          if (!Number.isFinite(ms)) return "-";
          return new Date(ms).toLocaleString();
        }

        async function appendRenderMetaSnapshot() {
          if (!bootLog) return;
          renderMetaRequestCount += 1;
          var backendBase = isLocal ? "http://localhost:3001" : "https://api.brianz.dev";
          var url = backendBase + "/api/site-performance/render/overview?hours=24";
          var now = new Date();
          var hh = String(now.getHours()).padStart(2, "0");
          var mm = String(now.getMinutes()).padStart(2, "0");
          var ss = String(now.getSeconds()).padStart(2, "0");
          var stamp = hh + ":" + mm + ":" + ss;
          var delay = 170;
          var cursor = 0;
          var accessLabel = systemAccessMode === "protocol" ? "Protocol access" : "Subject memory access";
          var accessCommand = systemAccessMode === "protocol"
            ? "protocol.access --window 24h --origin \"" + backendBase + "\""
            : "subject.memory.access --window 24h --origin \"" + backendBase + "\"";

          queueTerminalLine(cursor, delay, function () {
            pushBootLine("> " + accessLabel + " accepted [" + stamp + "] #" + renderMetaRequestCount, true);
          });
          cursor += 1;
          queueTerminalLine(cursor, delay, function () {
            pushBootLineHtml("&gt; run " + accessCommand, "api-line");
          });
          cursor += 1;
          queueTerminalLine(cursor, delay, function () {
            pushBootLine("> Query: GET /api/site-performance/render/overview?hours=24", false);
          });
          cursor += 1;
          queueTerminalLine(cursor, delay, function () {
            pushBootLine("> Memory channel: render telemetry + service state", false);
          });
          cursor += 1;
          setTerminalStatusText((systemAccessMode === "protocol" ? "protocol.access" : "subject.memory") + " // awaiting response", false);
          setTerminalOutputLoading("> processing telemetry stream");

          try {
            var response = await fetch(url);
            var payload = await response.json();
            if (!response.ok || !payload || payload.ok === false) {
              throw new Error((payload && payload.error) || "Render overview request failed.");
            }

            var summary = payload.summary || {};
            var services = Array.isArray(payload.services) ? payload.services : [];

            queueTerminalLine(cursor, delay, function () {
              pushBootLine("> Snapshot generated: " + formatDate(payload.generatedAt), false);
            });
            cursor += 1;
            queueTerminalLine(cursor, delay, function () {
              pushBootLine("> Services tracked: " + formatNumber(summary.serviceCount), false);
            });
            cursor += 1;
            queueTerminalLine(cursor, delay, function () {
              pushBootLine("> HTTP requests: " + formatNumber(summary.totalHttpRequests), false);
            });
            cursor += 1;
            queueTerminalLine(cursor, delay, function () {
              pushBootLine("> Bandwidth: " + formatBytes(summary.totalBandwidthBytes), false);
            });
            cursor += 1;
            queueTerminalLine(cursor, delay, function () {
              pushBootLine("> Avg CPU: " + formatPercent(summary.avgCpuPercent), false);
            });
            cursor += 1;
            queueTerminalLine(cursor, delay, function () {
              var avgMemory = summary.avgMemoryGb ? Number(summary.avgMemoryGb).toFixed(2) + " GB" : "-";
              pushBootLine("> Avg memory: " + avgMemory, false);
            });
            cursor += 1;
            queueTerminalLine(cursor, delay, function () {
              pushBootLine("> Postgres memory-health channel: pending integration", false);
            });
            cursor += 1;

            if (services.length) {
              services.slice(0, 8).forEach(function (service) {
                queueTerminalLine(cursor, delay, function () {
                  var name = service.name || "unnamed-service";
                  var type = service.type || "-";
                  var region = service.region || "-";
                  var runtime = service.runtime || "-";
                  pushBootLineHtml(
                    "&gt; <strong>[svc]</strong> " + name + "  // type: " + type + " | region: " + region + " | runtime: " + runtime,
                    "api-line"
                  );
                });
                cursor += 1;
              });
              if (services.length > 8) {
                queueTerminalLine(cursor, delay, function () {
                  pushBootLine("> ... +" + (services.length - 8) + " additional services", false);
                });
                cursor += 1;
              }
            } else {
              queueTerminalLine(cursor, delay, function () {
                pushBootLine("> No services returned for this snapshot", false);
              });
              cursor += 1;
            }

            queueTerminalLine(cursor, delay, function () {
              pushBootLine("> " + accessLabel + " stream complete", true);
            });
            cursor += 1;
          } catch (error) {
            queueTerminalLine(cursor, delay, function () {
              pushBootLine("> " + accessLabel + " stream error: " + String(error && error.message ? error.message : error), true);
            });
            cursor += 1;
          } finally {
            setTerminalOutputLoading("");
          }

          queueTerminalLine(cursor, delay, function () {
            pushBootLine("> Press ESC or tap Close to collapse terminal view", false);
            applyTerminalModeStatus();
          });
          terminalQueueOffset += (cursor + 1) * delay;
        }

        if (metaLink) {
          metaLink.addEventListener("click", function (event) {
            if (event.metaKey || event.ctrlKey || event.shiftKey || event.altKey) return;
            event.preventDefault();
            beginSubjectMemoryAccess();
          });
        }

        if (protocolLink) {
          protocolLink.addEventListener("click", function (event) {
            if (event.metaKey || event.ctrlKey || event.shiftKey || event.altKey) return;
            event.preventDefault();
            beginSubjectMemoryAccess("protocol");
          });
        }

        if (contactLink) {
          contactLink.addEventListener("click", function (event) {
            if (event.metaKey || event.ctrlKey || event.shiftKey || event.altKey) return;
            event.preventDefault();
            setContactTerminalExpanded(true);
            beginContactRelay();
          });
        }

        if (rebootLink) {
          rebootLink.addEventListener("click", function (event) {
            event.preventDefault();
            window.location.reload();
          });
        }

        if (memoryLink) {
          memoryLink.addEventListener("click", function (event) {
            if (event.metaKey || event.ctrlKey || event.shiftKey || event.altKey) return;
            event.preventDefault();
            beginSubjectMemoryAccess("memory");
          });
        }

        window.addEventListener("keydown", function (event) {
          if (event.key === "Escape" && opsExpanded) {
            setOpsExpanded(false);
          }
          if (event.key === "Escape" && terminalExpanded) {
            setTerminalExpanded(false);
          }
        });

        if (terminalCloseBtn) {
          terminalCloseBtn.addEventListener("click", function () {
            if (terminalExpanded) {
              setTerminalExpanded(false);
              return;
            }
            setTerminalExpanded(true);
          });
        }

        syncTerminalToggleControl();

        var bootSequence = [
          { text: "> Initiating protocol: NX-7A19.442", highlight: false },
          { text: "> Calibrating navigation bus...", highlight: false },
          { text: "> Mapping subject neural topology", highlight: true },
          { text: "> Rendering neural routes and access nodes", highlight: false },
          { text: "> Interface online.", highlight: true }
        ];
        var referrer = String(document.referrer || "");
        var shouldSkipBoot = subAppHosts.some(function (hostMarker) {
          return referrer.indexOf(hostMarker) !== -1;
        });
        nodeState = nodes.map(function (node, index) {
          var x = Number(node.getAttribute("data-x") || 50) / 100;
          var y = Number(node.getAttribute("data-y") || 50) / 100;
          var state = {
            el: node,
            x: x,
            y: y,
            phase: index * 1.2,
            lx: 0,
            ly: 0,
            px: 0,
            py: 0
          };
          if (node.id === "ops-link") {
            opsAnchorState = state;
          }
          return state;
        });

        latticePulseLines = nodes.map(function (_node, index) {
          return {
            nodeIndex: index,
            phase: index * 0.72,
            speed: 0.24 + (index % 3) * 0.055
          };
        });

        var latticeCanvas = document.getElementById("lattice-layer");
        var latticeCtx = latticeCanvas ? latticeCanvas.getContext("2d") : null;
        var corePoint = { x: 0, y: 0 };

        function updateNodeLayout() {
          if (!organism) return;
          var rect = organism.getBoundingClientRect();
          var hudRect = mapHud ? mapHud.getBoundingClientRect() : null;
          var hudHeight = hudRect ? hudRect.height : 0;
          // Keep map geometry stable across terminal expand/collapse.
          var safeTop = Math.max(20, 18 + hudHeight);
          var safeBottom = Math.max(150, Math.min(230, rect.height * 0.28));
          if (window.innerHeight <= 760) {
            safeBottom = Math.max(132, Math.min(200, rect.height * 0.25));
          }
          var usableTop = safeTop;
          var usableHeight = Math.max(1, rect.height - safeTop - safeBottom);

          var inMapMode = !!(mapActivated || (starfield && starfield.classList.contains("map-active")));
          if (inMapMode) {
            var rowY = usableTop + Math.min(58, Math.max(36, usableHeight * 0.12));
            var rowCount = Math.max(1, nodeState.length);
            var rowSpacing = Math.min(178, Math.max(104, rect.width / (rowCount + 1)));
            var rowStart = (rect.width * 0.5) - (((rowCount - 1) * rowSpacing) * 0.5);

            for (var i = 0; i < nodeState.length; i += 1) {
              var rowState = nodeState[i];
              var rowX = rowStart + (i * rowSpacing);
              rowState.lx = rowX;
              rowState.ly = rowY;
              rowState.px = rect.left + rowX;
              rowState.py = rect.top + rowY;
              rowState.el.style.transform = "translate(-50%, -50%) translate(" + rowX.toFixed(2) + "px," + rowY.toFixed(2) + "px)";
            }
          } else {
            for (var j = 0; j < nodeState.length; j += 1) {
              var state = nodeState[j];
              var x = state.x * rect.width;
              var y = usableTop + (state.y * usableHeight);
              state.lx = x;
              state.ly = y;
              state.px = rect.left + x;
              state.py = rect.top + y;
              state.el.style.transform = "translate(-50%, -50%) translate(" + x.toFixed(2) + "px," + y.toFixed(2) + "px)";
            }
          }

          if (brainCore) {
            var sinking = !!(starfield && starfield.classList.contains("intro-sinking"));
            if (inMapMode || sinking) {
              if (brainDockedY === null) {
                var panelHeight = terminalPanel ? terminalPanel.getBoundingClientRect().height : 210;
                brainDockedY = rect.height - (panelHeight * 0.34);
              }
              brainCore.style.top = brainDockedY.toFixed(2) + "px";
            } else {
              var centeredY = usableTop + (usableHeight * 0.5);
              brainCore.style.top = centeredY.toFixed(2) + "px";
            }
          }

          if (brainCore) {
            var coreRect = brainCore.getBoundingClientRect();
            corePoint.x = coreRect.left + coreRect.width * 0.5;
            corePoint.y = coreRect.top + coreRect.height * 0.5;
          } else {
            corePoint.x = rect.left + rect.width * 0.5;
            corePoint.y = rect.top + rect.height * 0.5;
          }

          if (starfield) {
            var starRect = starfield.getBoundingClientRect();
            var glowX = ((corePoint.x - starRect.left) / Math.max(1, starRect.width)) * 100;
            var glowY = ((corePoint.y - starRect.top) / Math.max(1, starRect.height)) * 100;
            var gx = Math.max(0, Math.min(100, glowX));
            var gy = Math.max(0, Math.min(100, glowY));
            starfield.style.setProperty("--brain-glow-x", gx.toFixed(2) + "%");
            starfield.style.setProperty("--brain-glow-y", gy.toFixed(2) + "%");
          }
        }

        function updateOpsSubNodeLayout() {
          if (!opsAnchorState) return;

          var target = opsExpanded ? 1 : 0;
          opsExpandProgress += (target - opsExpandProgress) * 0.16;
          if (Math.abs(target - opsExpandProgress) < 0.002) {
            opsExpandProgress = target;
          }

          for (var i = 0; i < opsSubNodes.length; i += 1) {
            var node = opsSubNodes[i];
            var offsetX = Number(node.getAttribute("data-offset-x") || 0);
            var offsetY = Number(node.getAttribute("data-offset-y") || 0);
            var x = opsAnchorState.lx + offsetX * opsExpandProgress;
            var y = opsAnchorState.ly + offsetY * opsExpandProgress;
            var scale = 0.8 + (opsExpandProgress * 0.2);
            var interactive = opsExpandProgress > 0.46;
            node.style.transform = "translate(-50%, -50%) translate(" + x.toFixed(2) + "px," + y.toFixed(2) + "px) scale(" + scale.toFixed(3) + ")";
            node.style.opacity = (opsExpandProgress * 0.98).toFixed(3);
            node.style.pointerEvents = interactive ? "auto" : "none";
            node.setAttribute("aria-hidden", interactive ? "false" : "true");
            node.setAttribute("tabindex", interactive ? "0" : "-1");
          }
        }

        function updateBrainTilt(timeSec) {
          if (!organism) return;
          var targetX = 0;
          var targetY = 0;
          brainTiltX += (targetX - brainTiltX) * 0.08;
          brainTiltY += (targetY - brainTiltY) * 0.08;
          organism.style.setProperty("--brain-tilt-x", brainTiltX.toFixed(2) + "deg");
          organism.style.setProperty("--brain-tilt-y", brainTiltY.toFixed(2) + "deg");
        }

        function resizeLattice() {
          if (!latticeCanvas || !latticeCtx) return;
          var w = Math.max(1, Math.floor(window.innerWidth * window.devicePixelRatio));
          var h = Math.max(1, Math.floor(window.innerHeight * window.devicePixelRatio));
          if (latticeCanvas.width !== w || latticeCanvas.height !== h) {
            latticeCanvas.width = w;
            latticeCanvas.height = h;
          }
          latticeCtx.setTransform(window.devicePixelRatio, 0, 0, window.devicePixelRatio, 0, 0);
          updateNodeLayout();
          updateOpsSubNodeLayout();
          resizeBrainViewport();
        }

        if (brainCore) {
          brainCore.addEventListener("click", function () {
            triggerBrainEntry(shouldSkipBoot, bootSequence);
          });
          brainCore.addEventListener("pointerdown", function (event) {
            if (!mapActivated) return;
            if (event.button !== 0) return;
            brainDragActive = true;
            brainDragPointerId = event.pointerId;
            brainShakeMeter = 0;
            brainShakeSessionEnergy = 0;
            brainShakeMildIssued = false;
            brainShakeStrongIssued = false;
            subjectAlertLastMotionAt = Date.now();
            if (brainCore.setPointerCapture) {
              brainCore.setPointerCapture(event.pointerId);
            }
            brainCore.classList.add("is-dragging");
            event.preventDefault();
          });
          brainCore.addEventListener("pointermove", function (event) {
            if (!brainDragActive || event.pointerId !== brainDragPointerId) return;
            var nextY = brainUserRotY + (event.movementX * 0.28);
            var nextX = brainUserRotX + (event.movementY * 0.24);
            brainUserRotY = Math.max(-70, Math.min(70, nextY));
            brainUserRotX = Math.max(-42, Math.min(42, nextX));
            var dragDelta = Math.abs(event.movementX) + Math.abs(event.movementY);
            brainShakeMeter = (brainShakeMeter * 0.86) + dragDelta;
            brainShakeSessionEnergy += dragDelta;
            if (dragDelta > 10) {
              subjectAlertLastMotionAt = Date.now();
            }
            if (!brainShakeMildIssued && (brainShakeMeter > 120 || brainShakeSessionEnergy > 650)) {
              signalBrainShakeWarning("mild");
              brainShakeMildIssued = true;
              brainShakeMeter = 42;
            }
            if (!brainShakeStrongIssued && (brainShakeMeter > 155 || brainShakeSessionEnergy > 1050)) {
              signalBrainShakeWarning("strong");
              brainShakeStrongIssued = true;
              brainShakeMeter = 58;
            }
          });
          brainCore.addEventListener("pointerup", function (event) {
            if (event.pointerId !== brainDragPointerId) return;
            brainDragActive = false;
            brainDragPointerId = null;
            if (brainCore.releasePointerCapture) {
              try { brainCore.releasePointerCapture(event.pointerId); } catch (_error) {}
            }
            brainCore.classList.remove("is-dragging");
          });
          brainCore.addEventListener("pointercancel", function (event) {
            if (event.pointerId !== brainDragPointerId) return;
            brainDragActive = false;
            brainDragPointerId = null;
            brainCore.classList.remove("is-dragging");
          });
          brainCore.addEventListener("keydown", function (event) {
            if (event.key === "Enter" || event.key === " ") {
              event.preventDefault();
              triggerBrainEntry(shouldSkipBoot, bootSequence);
            }
          });
        }

        window.addEventListener("resize", resizeLattice);
        resizeLattice();
        startLatticeLoop();

        function drawLinks(timeSec) {
          if (!latticeCtx || !latticeCanvas) return;

          latticeCtx.clearRect(0, 0, latticeCanvas.width, latticeCanvas.height);
          latticeCtx.lineWidth = 2.2;

          for (var i = 0; i < latticePulseLines.length; i += 1) {
            var stream = latticePulseLines[i];
            var target = nodeState[stream.nodeIndex];
            if (!target) continue;

            var pulse = 0.42 + (Math.sin(timeSec * 0.75 + stream.phase) + 1) * 0.07;
            latticeCtx.strokeStyle = "rgba(152, 214, 255," + pulse.toFixed(3) + ")";
            latticeCtx.beginPath();
            latticeCtx.moveTo(corePoint.x, corePoint.y);
            latticeCtx.lineTo(target.px, target.py);
            latticeCtx.stroke();

            var travel = (timeSec * stream.speed + stream.phase) % 1;
            var px = corePoint.x + (target.px - corePoint.x) * travel;
            var py = corePoint.y + (target.py - corePoint.y) * travel;
            var pulseRadius = 1.6 + (Math.sin((timeSec + stream.phase) * 3.4) + 1) * 0.62;
            var pulseGlow = latticeCtx.createRadialGradient(px, py, 0, px, py, pulseRadius * 5);
            pulseGlow.addColorStop(0, "rgba(236, 248, 255, 0.98)");
            pulseGlow.addColorStop(1, "rgba(224, 245, 255, 0)");
            latticeCtx.fillStyle = pulseGlow;
            latticeCtx.beginPath();
            latticeCtx.arc(px, py, pulseRadius * 5, 0, Math.PI * 2);
            latticeCtx.fill();
          }

          var coreGlowRadius = 16 + (Math.sin(timeSec * 0.8) + 1) * 2.2;
          var coreGlow = latticeCtx.createRadialGradient(corePoint.x, corePoint.y, 0, corePoint.x, corePoint.y, coreGlowRadius * 2.4);
          coreGlow.addColorStop(0, "rgba(186, 230, 255, 0.82)");
          coreGlow.addColorStop(1, "rgba(186, 230, 255, 0)");
          latticeCtx.fillStyle = coreGlow;
          latticeCtx.beginPath();
          latticeCtx.arc(corePoint.x, corePoint.y, coreGlowRadius * 2.4, 0, Math.PI * 2);
          latticeCtx.fill();

          for (var j = 0; j < nodeState.length; j += 1) {
            var n = nodeState[j];
            var r = 3 + ((Math.sin(timeSec * 1.2 + j * 0.7) + 1) * 1.1);
            var glow = latticeCtx.createRadialGradient(n.px, n.py, 0, n.px, n.py, r * 4);
            glow.addColorStop(0, "rgba(180, 224, 255, 0.76)");
            glow.addColorStop(1, "rgba(180, 224, 255, 0)");
            latticeCtx.fillStyle = glow;
            latticeCtx.beginPath();
            latticeCtx.arc(n.px, n.py, r * 4, 0, Math.PI * 2);
            latticeCtx.fill();
          }
        }

        function updateLattice(now) {
          var timeSec = now * 0.001;
          if (subjectAlertTarget > 0 && (!brainDragActive || (Date.now() - subjectAlertLastMotionAt) > 520)) {
            subjectAlertTarget = 0;
          }
          subjectAlertLevel += (subjectAlertTarget - subjectAlertLevel) * (subjectAlertTarget > subjectAlertLevel ? 0.16 : 0.08);
          if (Math.abs(subjectAlertTarget - subjectAlertLevel) < 0.01) {
            subjectAlertLevel = subjectAlertTarget;
          }
          if (starfield) {
            starfield.style.setProperty("--subject-alert-opacity", subjectAlertLevel.toFixed(3));
            starfield.classList.toggle("subject-alert-critical", subjectAlertLevel > 0.06);
          }
          if (mapActivated && !brainDragActive) {
            brainUserRotX *= 0.92;
            brainUserRotY *= 0.92;
            if (Math.abs(brainUserRotX) < 0.01) brainUserRotX = 0;
            if (Math.abs(brainUserRotY) < 0.01) brainUserRotY = 0;
          }
          updateBrainTilt(timeSec);
          if (mapActivated || introTransitionActive) {
            updateNodeLayout();
          }
          if (mapActivated) {
            updateOpsSubNodeLayout();
            drawLinks(timeSec);
          } else if (latticeCtx && latticeCanvas) {
            latticeCtx.clearRect(0, 0, latticeCanvas.width, latticeCanvas.height);
          }
          renderThreeBrain(timeSec);
          requestAnimationFrame(updateLattice);
        }

        function startLatticeLoop() {
          if (latticeLoopStarted) return;
          latticeLoopStarted = true;
          requestAnimationFrame(updateLattice);
        }

        var depthCanvas = document.getElementById("depth-layer");
        if (!depthCanvas) return;

        var gl = depthCanvas.getContext("webgl", { antialias: true, alpha: true, premultipliedAlpha: true });
        if (!gl) return;

        var vert = "attribute vec2 a_pos;attribute float a_seed;uniform float u_time;varying float v_seed;void main(){float t=u_time*0.22+a_seed*6.283;vec2 drift=vec2(cos(t)*0.03,sin(t*0.64)*0.05);vec2 p=a_pos+drift;gl_Position=vec4(p,0.0,1.0);gl_PointSize=1.5+4.8*fract(a_seed*19.13);v_seed=a_seed;}";
        var frag = "precision mediump float;varying float v_seed;void main(){vec2 uv=gl_PointCoord-vec2(0.5);float d=dot(uv,uv);float glow=smoothstep(0.28,0.0,d);vec3 c1=vec3(0.44,0.76,1.0);vec3 c2=vec3(0.88,0.74,0.45);vec3 col=mix(c1,c2,fract(v_seed*10.7));gl_FragColor=vec4(col,glow*0.46);}";

        function compile(type, source) {
          var shader = gl.createShader(type);
          if (!shader) return null;
          gl.shaderSource(shader, source);
          gl.compileShader(shader);
          if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            gl.deleteShader(shader);
            return null;
          }
          return shader;
        }

        var vs = compile(gl.VERTEX_SHADER, vert);
        var fs = compile(gl.FRAGMENT_SHADER, frag);
        if (!vs || !fs) return;

        var program = gl.createProgram();
        if (!program) return;
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) return;
        gl.useProgram(program);

        var count = 190;
        var data = new Float32Array(count * 3);
        for (var i = 0; i < count; i += 1) {
          var idx = i * 3;
          data[idx] = Math.random() * 2 - 1;
          data[idx + 1] = Math.random() * 2 - 1;
          data[idx + 2] = Math.random();
        }

        var buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);

        var stride = 3 * 4;
        var posLoc = gl.getAttribLocation(program, "a_pos");
        var seedLoc = gl.getAttribLocation(program, "a_seed");
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, stride, 0);
        gl.enableVertexAttribArray(seedLoc);
        gl.vertexAttribPointer(seedLoc, 1, gl.FLOAT, false, stride, 2 * 4);

        var timeLoc = gl.getUniformLocation(program, "u_time");

        function resizeDepth() {
          var w = Math.max(1, Math.floor(window.innerWidth * window.devicePixelRatio));
          var h = Math.max(1, Math.floor(window.innerHeight * window.devicePixelRatio));
          if (depthCanvas.width !== w || depthCanvas.height !== h) {
            depthCanvas.width = w;
            depthCanvas.height = h;
          }
          gl.viewport(0, 0, depthCanvas.width, depthCanvas.height);
        }

        window.addEventListener("resize", resizeDepth);

        function drawDepth(now) {
          resizeDepth();
          gl.clearColor(0, 0, 0, 0);
          gl.clear(gl.COLOR_BUFFER_BIT);
          gl.uniform1f(timeLoc, now * 0.001);
          gl.drawArrays(gl.POINTS, 0, count);
          requestAnimationFrame(drawDepth);
        }

        requestAnimationFrame(drawDepth);
      })();
    </script>
  </body>
</html>
